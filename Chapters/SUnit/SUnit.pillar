!!SUnit: The framework
@cha:sunit

Now that you see that writing a test is easy, we will take the time to put in perspective the different aspects of SUnit. 
SUnit is a framework in the sense that it proposes an architecture that can be adapted. We will not cover the techniques 
to extend the framework but we will present the key classes and discuss some important points. 

!!!Understanding the framework

What we saw in the previous chapter is that a test method defines a test.
Now there is a catch: 
- A method (called a test method) of a subclass of the class ==TestCase== represents a test.
- A ==TestCase== subclass groups together all the tests sharing a similar context, called a ''fixture''.
- A ==setUp== method is run systematically before a test method is run and a ==tearDown== after.
- The framework builds a ==TestSuite== (a composite of tests) to execute the tests.



!!! During test execution

Figure *@fig:sunit-execution* shows the steps during the execution ==run== of a test:
- An instance of ==TestCase== is created.
- It creates an instance of ==TestResult==.
- This instance calls back the ==TestCase== instance which executes 
-- the test ==setUp==
-- the test method 
-- and finally the test ==tearDown== method.

+During ==run== execution.>file://figures/sunit-scenario.png|width=45|label=fig:sunit-execution+

In fact the framework ensures that any test method is always surrounded by the execution of the ==setUp== and ==tearDown== methods.
Figure *@fig:setUpAndTearDown* illustrates this point.
It ensures that the fixture is always in a correct state and avoid dependencies between test execution.

+setUp and teardDown in action.>file://figures/setUpAndTearDown.pdf|width=80|label=fig:setUpAndTearDown+


!!! The framework in a nutshell

SUnit consists of four main classes: ==TestCase==, ==TestSuite==,
==TestResult==, and ==TestResource==, as shown in Figure *@fig:sunit-classes*.

+The four classes representing the core of SUnit.>file://figures/sunit-classes.png|width=80|label=fig:sunit-classes+

!!!! TestCase

==TestCase== is an abstract class that is designed to be subclassed. Each of its
subclasses represents a ""group"" of tests that share a common context: such a group is called a ""test suite"".

Each test is run by creating a new instance of a subclass of ==TestCase==, running ==setUp== to initialize the test fixture, running the test method itself, and then sending the ==tearDown== to clean up the test fixture.

The fixture is specified by instance variables of the subclass and by the specialization of the method ==setUp==, which initializes those instance
variables. Subclasses of ==TestCase== can also override method ==tearDown==,
which is invoked after the execution of each test, and can be used to release
any objects allocated during ==setUp==.

!!!!TestSuite
Instances of the class ==TestSuite== contain a collection of test cases. An
instance of ==TestSuite== contains tests, and other test suites. That is, a test
suite contains sub-instances of ==TestCase== and ==TestSuite==.
Both individual test cases and test suites understand the same protocol, so
they can be treated in the same way (for example, both can be ==run==). This is
in fact an application of the Composite pattern in which ==TestSuite== is the
composite and the test cases are the leaves.

!!!!TestResult

The class ==TestResult== represents the results of a ==TestSuite== execution.
It records the number of tests passed, the number of tests failed, and the
number of errors signalled.

!!!! TestResources

The notion of a ''test resource'' represents a resource that is expensive to
set-up but which can be used by a whole series of tests. 
A ==TestResource== specifies a ==setUp== method that is executed just once before a full suite of tests;
this is in distinction to the ==TestCase >> setUp== method, which is executed before each test.
The class ==TestResource== represents resources that can be shared among a test suite:
Subclasses of ==TestResource== are associated to test case classes and this means that all the suite of tests
represented by the test case class (See Chapter *@cha:cookbook*).


!!! Test states

As we mentioned earlier, the results of a test execution is mainly: passed (meaning that it succeeded), fails (that an assertion is not valid) or error (that an unexpected problem occurred).


!!!!Failures vs. Error
In fact this is really important to understand the difference between a failure and an error. A failure is something that you plan and you check whether is happened or not. When it happens your tests pass, else it fails.

Remove an element that is not in a set from that set raises and error. If we write the following test, the test will fail.

[[[caption=Testing removal of unexisting element.
MyExampleSetTest >> testRemoveInexistentElement
	empty remove: 5.
]]]

Now using the message ==should:raise:== we make sure that we check that the expression effectively raises an error. 
It means that our test can either pass (i.e., it means that the test fulfil our requirement here that it should raise an error when removing an unknown element) or fail. We planned such behavior. It can fail or pass. 

[[[caption=Testing removal of an inexistent element.
MyExampleSetTest >> testRemoveInexistentElement

	self should: [ empty remove: 5 ] raise: NotFound
]]]

For an error this is different, an error occurs in an unplanned manner. 
The execution of the first version of ==testRemoveInexistentElement== would lead to an error.


!!!! Expected Failures and Skip

In addition a test can be in two other states: skipped and expectedFailures.
Such states are handy during development. 

The idea is that if you write a complex tests and suddently you realize that you will have more work than expected to make your
test passes, you can mark it as skipped.


[[[caption=An example of skipped test.
MyExampleSetTest >> testToBeRevisitedLater

	self skip.
	...
]]]

In fact it is much better to use the message ==skip== than use a guard.
Why because the framework can report clearly that your test is skipped. 
Using a guard as below is the best way to confuse yourself, because the framework
will return that the test passes while it does NOT.


[[[caption=A not so nice example of skipped test.
MyExampleSetTest >> testToBeRevisitedLater

	true ifTrue: [^ self ].
	...
]]]


You can also tag your test with the ==<expectedFailure>== pragma to indicate to the framework that you expect 
your test to fail. This is be taken into account by the framework when running and reporting all your tests. Hence you will be 
aware that some of your tests did not run correctly.
Here is an example from Pharo.

[[[
testFromClassWhichTraitIsExtendedButNotItself
	"I'm tagging this expected failure because I'm not sure now if it is appropriate to keep 
	 or not with the removal of the 'traits-as-multiple-inheritance' stuff."
	<expectedFailure>

	self queryFromScope: ClyClassScope of: ClyClassWithTraits.
	self assert: resultItems size equals: 0
]]]	
	


!!!Glossary


- ""Test case."" A test case is a single test. It defined a context, a stimulus and at the minimum one assertion. It is described as a method of a TestCase subclass starting with ""test"".
-  ""Test suite."" A test suite (Composite design pattern) is a group of tests. The tests belonging to a test suite do not have to be from the same class. In practice the test runner builds a test suite for all the test cases defined in a class and executes them one by one.  Instances of the class ==TestSuite== contain a collection of test cases.  An instance of ==TestSuite== contains tests, and other test suites. That is, a test suite contains sub-instances of ==TestCase== and ==TestSuite==.
- ""Fixture."" A fixture is a context in which a stimulus will be executed and assertions verified. To share a fixture amongst multiple tests you can define the ==setUp== method. It is automatically invoked before any test method execution.
- ""Failure."" A failure is the situation where you planned something and checked it and it is not correct.
- ""Error."" An error is the situation where your test is not working but it is not covered by an assertion. For example, a message not understood is sent and it was unexpected.

!!!Chapter summary

This chapter we gave an overview of the core of the SUnit framework
by presenting the classes ==TestCase==, ==TestResult==, ==TestSuite== and
==TestResources==. We described the setUp/tearDown logic and the different states a test can be in.

