!!The SUnit cookbook

This chapter will give you more details on how to use SUnit. If you have used
another testing framework such as JUnit, much of this will be familiar, since
all these frameworks have their roots in SUnit. Normally you will use SUnit's
GUI to run tests, but there are situations where you may not want to use it.


!!!Other assertions

In addition to ==assert:== and ==deny:==, there are several other methods that
can be used to make assertions.

First, ==TestAsserter >> assert:description:== and ==TestAsserter >>
deny:description:== take a second argument which is a message string that
describes the reason for the failure, if it is not obvious from the test itself.
These methods are described in Section *@sec:descriptionStrings*.

Next, SUnit provides two additional methods, ==TestAsserter >> should:raise:==
and ==TestAsserter >> shouldnt:raise:== for testing exception propagation.

For example, you would use ==self should: aBlock raise: anException== to test
that a particular exception is raised during the execution of ==aBlock==. The
method below illustrates the use of ==should:raise:==.

[[[caption=Testing error raising
	MyExampleSetTest >> testIllegal
		self should: [ empty at: 5 ] raise: Error.
		self should: [ empty at: 5 put: #zork ] raise: Error
]]]

Try running this test. Note that the first argument of the ==should:== and
==shouldnt:== methods is a block that contains the expression to be executed.


!!!Using ==assert:equals:==

In addition to ==assert:==, there is also ==assert:equals:== that offers a
better report in case of error (incidentally, ==assert:equals:== uses
==assert:description:==).

For example, the two following tests are equivalent. However, the second one
will report the value that the test is expecting: this makes easier to
understand the failure. In this example, we suppose that ==aDateAndTime== is an
instance variable of the test class.

[[[
testAsDate
	self assert: aDateAndTime asDate = ('February 29, 2004' asDate translateTo: 2 hours).

testAsDate
	self
		assert: aDateAndTime asDate
		equals: ('February 29, 2004' asDate translateTo: 2 hours).
]]]


!!!Assertion description strings
@sec:descriptionStrings

The ==TestAsserter== assertion protocol includes a number of methods that allow
the programmer to supply a description of the assertion. The description is a
==String==; if the test case fails, this string will be displayed by the test
runner. Of course, this string can be constructed dynamically.

[[[
...
e := 42.
self assert: e = 23 description: 'expected 23, got ', e printString
...
]]]

The relevant methods in ==TestAsserter== are:

[[[
assert:description:
deny:description:
should:description:
shouldnt:description:
]]]

!!!Running a single test

Normally, you will run your tests using the Test Runner or using your code
browser. If you don't want to launch the Test Runner from the World menu, you
can execute ==TestRunner open==. You can also run a single test as follows:

[[[testcase=true
MyExampleSetTest run: #testRemove
>>> 1 run, 1 passed, 0 failed, 0 errors
]]]

!!!Running all the tests in a test class

Any subclass of ==TestCase== responds to the message ==suite==, which will build
a test suite that contains all the methods in the class whose names start with
the string ''test''.

To run the tests in the suite, send it the message ==run==. For example:

[[[testcase=true
MyExampleSetTest suite run
>>> 5 run, 5 passed, 0 failed, 0 errors
]]]

!!!Must I subclass TestCase?

In JUnit you can build a TestSuite from an arbitrary class containing ==test*==
methods. In SUnit you can do the same but you will then have to create a suite
by hand and your class will have to implement all the essential ==TestCase==
methods like ==assert:==. We recommend, however, that you not try to do this.
The framework is there: use it.




!!!Advanced features of SUnit

In addition to ==TestResource==, SUnit contains assertion description strings,
logging support, the ability to skip tests, and resumable test failures.


!!!!Logging support

The description strings mentioned above may also be logged to a ==Stream==, such
as the ==Transcript== or a file stream. You can choose whether to log by
overriding ==isLogging== in your test class; you must also choose where to log
by overriding ==failureLog== to answer an appropriate stream. By default, the
==Transcript== is used to log.

!!!!Skipping tests

Sometimes in the middle of a development, you may want to skip a test instead of
removing it or renaming it to prevent it from running. You can simply invoke the
==TestAsserter== message ==skip== on your test case instance. For example, the
following test uses it to define a conditional test.

[[[
OCCompiledMethodIntegrityTest >> testPragmas

	| newCompiledMethod originalCompiledMethod |
	(Smalltalk globals hasClassNamed: #Compiler) ifFalse: [ ^ self skip ].
	...
]]]

!!!! Continuing after a failure

SUnit also allows us to specify whether or not a test should continue after a
failure. This is a really powerful feature that uses Pharo's exception
mechanisms. To see what this can be used for, let's look at an example. Consider
the following test expression:

[[[
aCollection do: [ :each | self assert: each even ]
]]]

In this case, as soon as the test finds the first element of the collection that
isn't ==even==, the test stops. However, we would usually like to continue, and
see both how many elements, and which elements, aren't ==even== (and maybe also
log this information). You can do this as follows:

[[[
aCollection do: [ :each |
	self
		assert: each even
		description: each printString, ' is not even'
		resumable: true ]
]]]

This will print out a message on your logging stream for each element that
fails. It doesn't accumulate failures, i.e, if the assertion fails 10 times in
your test method, you'll still only see one failure. All the other assertion
methods that we have seen are not resumable by default;
==assert: p description: s== is equivalent to
==assert: p description: s resumable: false==.

!!! Test Resources

One of the important features of a suite of tests is that they should be
independent of each other. The failure of one test should not cause an avalanche
of failures of other tests that depend upon it, nor should the order in which
the tests are run matter. Performing ==setUp== before each test and ==tearDown==
afterwards helps to reinforce this independence.

However, there are occasions where setting up the necessary context is just too
time-consuming for it to be done before the execution of each
test. Moreover, if it is known that the test cases do not disrupt the resources
used by the tests, then it is wasteful to set them up afresh for each test. It
is sufficient to set them up once for each suite of tests. Suppose, for example,
that a suite of tests needs to query a database, or do analysis on some
compiled code. In such cases, it may make sense to set up the database and open
a connection to it, or to compile some source code, before any of the tests
start to run.

Where should we cache these resources, so that they can be shared by a suite of
tests? The instance variables of a particular ==TestCase== subclass won't
do, because a TestCase instance persists only for the duration of a single test
(as mentioned before, the instance is created anew ''for each test method''). A
global variable would work, but using too many global variables pollutes the
name space, and the binding between the global and the tests that depend on it
will not be explicit. A better solution is to put the necessary resources in a
singleton object of some class. The class ==TestResource== exists to be
subclassed by such resource classes. Each subclass of ==TestResource==
understands the message ==current==, which will answer a singleton instance of
that subclass. Methods ==setUp== and ==tearDown== should be overridden in the
subclass to ensure that the resource is initialized and finalized.

One thing remains: somehow, SUnit has to be told which resources are associated
with which test suite. A resource is associated with a particular subclass of
==TestCase== by overriding the ''class'' method ==resources==.

By default, the resources of a ==TestSuite== are the union of the resources of
the ==TestCase==s that it contains.

Here is an example. We define a subclass of ==TestResource== called
==MyTestResource==. Then we associate it with ==MyTestCase== by overriding the
class method ==MyTestCase class >> resources== to return an array of the test
resource classes that ==MyTestCase== will use.

[[[caption=An example of a TestResource subclass
TestResource subclass: #MyTestResource
	instanceVariableNames: ''
	...

MyTestCase class >> resources
	"Associate the resource with this class of test cases"

	^ { MyTestResource }
]]]

!!!! Checking the described behavior

The following trace (written to the ==Transcript==) illustrates that a global
set up is run before and after each test in a sequence. Let's see if you can
obtain this trace yourself.

[[[
MyTestResource >> setUp has run.
MyTestCase >> setUp has run.
MyTestCase >> testOne has run.
MyTestCase >> tearDown has run.
MyTestCase >> setUp has run.
MyTestCase >> testTwo has run.
MyTestCase >> tearDown has run.
MyTestResource >> tearDown has run.
]]]

Create new classes ==MyTestResource== and ==MyTestCase== which are subclasses of
==TestResource== and ==TestCase== respectively. Add the appropriate methods so
that the following messages are written to the ==Transcript== when you run your
tests.

!!!Solution
You will need to write the following six methods.

[[[
MyTestCase >> setUp
	Transcript show: 'MyTestCase>>setUp has run.'; cr

MyTestCase >> tearDown
	Transcript show: 'MyTestCase>>tearDown has run.'; cr

MyTestCase >> testOne
	Transcript show: 'MyTestCase>>testOne has run.'; cr

MyTestCase >> testTwo
	Transcript show: 'MyTestCase>>testTwo has run.'; cr

MyTestCase class >> resources
	^ Array with: MyTestResource

MyTestResource >> setUp
	Transcript show: 'MyTestResource>>setUp has run'; cr

MyTestResource >> tearDown
	Transcript show: 'MyTestResource>>tearDown has run.'; cr
]]]



!!! Parameterized Tests



